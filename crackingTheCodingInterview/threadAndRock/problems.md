## 1. 프로세스 vs 스레드 : 프로세스와 스레드의 차이는 무엇인가요

프로세스와 스레드는 서로 관련은 있지만 기본적으로 다릅니다.

프로세스는 실행되고 있는 프로그램의 인스턴스라고 생각할 수 있습니다.. 프로세스는 CPU  시간이나 메모리 등의 시스템 자원이 할당되는 독립적인 개체이다. 각 프로세스는 별도의 주소 공간에서 실행되며, 
한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다. 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스간 통신을 사용해야 합니다. 
프로세스간 통신 방법으로는 파이프, 파일, 소켓 등을 이용한 방법이 있습니다.

스레드는 프로세스 안에 존재하며 프로세스의 자원을 공유합니다. 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유합니다. 
각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만 힙 메모리는 서로 읽고 쓸 수 있습니다.

## 2. 문맥 전환 : Context switch 에 소요되는 시간을 측정하려면 어떻게 해야 할까

문맥 전환에 소요되는 시간은 두 프로세스를 전환하는 데 드는 시간입니다.

문맥 전환은 대기 중인 프로세스를 실행 상태로 전환하고, 실행 중인 프로세스를 대기 상태나 종료 상태로 전환하는 과정입니다. 
그리고 문맥 전환에 소요되는 시간은 두 프로세스를 전환하는 데 드는 시간을 의미합니다. 
문맥 전환에 소요되는 시간을 측정하기 위해서는, 상태를 전환할 두 프로세스의 마지막과 첫 번째 명령어와 타임스탬프를 기록해야한다. 문맥 전환에 걸리는 시간은 그 두 프로세스의 타임스탬프의 차이와 같습니다. 

P1, P2 두 프로세스간 토큰을 보내고 받는 과정에서 문맥 전환이 발생하며 이를 통해서 시간을 측정할 수 있습니다.

1. P2는 P1의 데이터를 기다리며 블록된다.
2. P1이 시작 시간을 기록한다.
3. P1이 P2에서 토큰을 보낸다.
4. P1은 P2가 보내는 응답 토큰을 읽으려 한다. 그 순간 문맥 전환이 발생한다.
5. P2가 스케줄링되고 토큰을 수신한다
6. P2가 응답 토큰을 P1에게 보낸다.
7. P2는 P1이 보내는 응답 토큰을 읽으려 한다. 그 순간 다시 문맥 전환이 발생한다.
8. P1이 스케줄링되어 토큰을 받는다.
9. P1이 종료 시간을 기록한다.

#2 와 #9 사이에 커널 인터럽트가 발생하거나 다른 커널 스레드가 끼어들거나 할 수 있으므로 이에 대한 영향을 제거 하기 위해 여러번 실행하여 평균치의 최소값을 최종적인 해답으로합니다.
(이 풀이는 그저 근사치일 뿐입니다. 어떤 시스템에서 실험했느냐에 따라 달라 질 수 있다. 스케줄러의 구현 방식에 따라서 p2를 다음에 실행할 프로세스로 선택할 것이라는 보장이 없기 때문이다.)


## 5. 순서대로 호출 : 다음과 같은 코드가 있다고 하자 Foo 인스턴스 하나를 서로 다른 세 스레드에 전달 합니다. threadA는 first를 호출할 것이고 threadB는 second를 호출할 것이며, threadC는 third를 호출할 것이다. First -> second -> third순으로 호출되도록 보장하는 메커니즘을 설계하라.
```
Public class Foo {
	public Foo() {}
	public void first() {}
	public void second() {}
	public void third() {}

}
```
세마포어는 Signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있습니다. 
세마포어를 활용하여 하기와 같이 설계합니다.

```
public class Foo {
    public Semaphore sem1, sem2;

    public Foo() {
        try {
            sem1 = new Semaphore(1);
            sem2 = new Semaphore(1);

            sem1.acquire();
            sem2.acquire();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void first() {
        System.out.println("first call");
        sem1.release();
    }

    public void second() {
        try {
            sem1.acquire();
            sem1.release();
            System.out.println("second call");

            sem2.release();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void third() {
        try {
            sem2.acquire();
            sem2.release();

            System.out.println("third call");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```


## 6. 동기화된 메서드 : 동기화된 메서드 A와 일반 메서드 B가 구현된 클래스가 있다. 같은 프로그램에서 실행되는 스레드가 두 개 존재할 때 A를 동시에 실행할 수 있는가? A와B는 동시에 실행될 수 있는가?

첫 번째 질문은 상황에 따라 다릅니다. 두 스레드가 같은 객체를 갖고 있다면 답은 No입니다. 메서드 A를 동시에 실행할 수 없습니다.
하지만 다른 객체라면 yes입니다. 동시에 실행할 수 있습니다.

두 번째 질문은 가능합니다. 
객체별로 실행 가능한 synchronized메서드는 하나뿐입니다. 다른 스레드는 해당 객체의 일반 메서드 혹은 다른 객체의 메서드는 실행할 수 있습니다.
