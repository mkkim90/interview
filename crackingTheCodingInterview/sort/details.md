## 정렬


### 버블 정렬 | 평균 및 최악 실행 시간 : O(n^2), 메모리 : O(1)

  배열의 첫 원소부터 순차적으로 진행하며, 현재 원소가 그 다음 원소의 값보다 크면 두 원소를 바꾸는 작업을 반복

### 선택 정렬 | 평균 및 최악 실행 시간 : O(n^2), 메모리 : O(1)

	
  선택 정렬은 아이들도 고안해 낼 수 있을 만큼 심플한 알고리즘이다. 하지만 비효율적이다.
  선형탐색하며 가장 작은 원소를 배열 맨 앞으로 보낸다.  그다음에는 두번째로 작은 원소를 찾은 뒤 앞으로 보내준다. 이 작업을 모든 원소가 정렬될 때까지 반복한다. 


### 병합 정렬 (merge sort) | 평균 및 최악 실행 시간 O(nlog n) , 메모리 : 상황에 따라 다름

  병합 정렬은 배열을 절반씩 나누어 각각을 정렬한 다음 이 둘을 합하여 다시 정렬하는 방법이다.
  나눈 절반을 정렬할 때도 같은 알고리즘이 사용되고 결국에는 원소 한개 짜리 배열 두개를 병합하게 된다. 

### 퀵 정렬 | 평균 O(n log n), 최악 O(n^2), 메모리 : O(log n)
 	
  무작위로 선정된 한 원소를 사용하여 배열을 분할하는데, 선정된 원소보다 작은 원소들은 앞에, 큰 원소들은 뒤로 보낸다. 
  배열 분할 작업은 연속된 스왑 연산을 통해 효율적으로 수행된다.

  배열과 그 부분 배열을 반복적으로 분할해 나가면 결국에 배열은 정렬된 상태에 도달한다. 
  하지만 배열 분할에 사용되는 원소가 중간값, 적어도 중간값에 가까운 값이 되리라는 보장이 없기 때문에 정렬 알고리즘이 느리게 동작할 수도 있다. 
