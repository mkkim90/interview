- 회사에서 최근에 했던 일과 문제해결 및 원인 찾았던 부분 설명하시오.

- n+1 이슈 관련해서 아는 부분과 해결 방법에 대해 설명하시오.

- 네트워크 대역폭 관리하는 방법에 대해 설명하시오.

- DB 인덱스 설명하시오.

- 이직하게 된 이유가 무엇인가요? 
```
서비스 플랫폼 회사에서 백엔드 개발자로써, 성장하고 싶어서 이직을 결심하게 되었습니다.
```

- DI와 DI를 사용하게된 이유가 무엇인가요?
```
의존성 주입이란 필요한 클래스를 직접 생성하는 것이 아닌, 주입해줌으로써 외부로 부터 필요한 객체를 받아서
사용하는 겁니다. 이를 통해 객체간의 결합도를 줄이고 더 유연한 코드를 작성할 수 있게됩니다.
```

- DDD 장점이 무엇일까요?
```
도메인주도설계를 통해 도메인 중점적으로 깊이 있게 알수 있으며, 기존 비즈니스 레이어 계층의 두터운 부분을 도메인 계층으로 옮겨지면서 
높은 응집력과 낮은 결합도를 형성합니다.
```

- AOP 사용 사례
```
인프라 혹은 부가 기능의 모듈화로 활용하면 좋습니다. 대표적인 예로 로깅, 트랜잭션, 보안 또는 검증 부분으로 활용할 수 있습니다.

공통된 기능을 재사용하는 기법으로, 부가 기능들을 상속이나 위임으로 처리하기에는 깔끔하게 모듈화가 어려우므로 
이 문제를 해결하기 위해 횡단적 관점 분리인 AOP가 등장하게 되었습니다.

어플리케이션 전체에 흩어진 공통기능이 하나의 장소에 관리된다는 점과 다른 서비스 모듈들이 
본인의 목적에만 충실하고 그 외 사항들은 신경쓰지 않아도 된다는점에서 유용합니다.
```

- 알고리즘 그리디
```
당장 최적인 답을 선택하여 적합한 결과를 도출하는 것을 모토로 가지는 알고리즘 설계 기법
부분의 최적 해들의 집합이 곧 전체 문제의 해답이 될 때 사용할 수 있습니다.
```

- Java 1.7과 Java 1.8 차이
```
Java1.8부터 스트림 API와 람다표현식을 사용 가능합니다.

람다표현식은 식별자 없이 실행할 수 있는 함수 표현식을 의미합니다. 이를 통해서 함수 프로그래밍을 할 수 있습니다.

스트림 API는 반복문이나 반복자를 사용하여 코드를 작성하는 것이 아닌 Stream API를 통해 데이터의 추상화하여
다루게 되었습니다.

저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공합니다.
```

- 보안취약점 개선한 경험이 있나요? 해당 경험에 대해 설명하시오.

```
1. SQL 인젝션는 악의적인 사용자가 보안상의 취약점을 이용하여 임의의 SQL문을 주입하고 실행되게 하여 비정상적인
   동작을 하도록 조작 행위를 말합니다.
   
   Prepare statement활용(선처리 질의문)을 이용합니다. 동적쿼리의 경우 성능상 문제와 사용자 입력 값에 따라 의도하
   지 않은 쿼리가 실행 될 수 있는 가능성이 있습니다. 선처리 질의문은 외부로부터 입력값을 제외한 쿼리부분을 
   미리 컴파일 한 후 반복적으로 입력 값만을 설정해서 실행하는 방식으로 성능상 장점과 쿼리문 자체로 미리 컴파일되어 
   입력값에 의해 영향을 받지 않으므로 SQL Injection 공격을 방어하는 효과가 있습니다.
   
2. CRSF 공격은 사이트 간 요청 위조 웹 어플리케이션 취약점 중 하나로, 사용자가 자신의 의지와 무관하게 공격자가 
   의도한 행동을 하는 케이스입니다. 방지효과로 레퍼럴 체크 및 토큰활용한 경험이 있습니다.
3. Xss 필터간 악성 스크립트 코드를 삽입한 공격이다. 방지효과로 스크립트 언어 필터링을 한 경험이 있습니다.   
```

- 해왔던 업무 관련해서 소개
```
콘텐츠 관련 API/WEB을 개발한 경험이 있습니다. SK임직원몰인 이패밀리샵과 보험 마켓팅 시스템인 TAS를 운영해왔습니다.
그리고 최근에는 KB생명에서 가입설계 청약 관련 비대면 모바일 영업 시스템을 개발 및 운영해왔습니다.
```

- 우아한 테크 캠프
```
TDD/DDD/리팩토링/객체지향프로그래밍 관련 미션 과제를 수행하면서 코드를 리뷰 요청하고 피드백을 받은 것을 고치는
사이클로 진행하였습니다. 기간내에 모든 미션을 완수하였으며 우수수료생으로 이수하였습니다.
```

- TDD 장단점
```
장점 : 
추가 구현의 용이함
보다 튼튼한 객체 지향적인 코드 생산
재설계 시간의 단축
테스트 문서의 대체 가능
디버깅 시간의 단축

가장 큰 단점은 생산성의 저하입니다.
```

- 성능 모니터링 및 최적화 학습은 어떤 것인지 설명해주세요.
```
주로 부하테스트와 성능 최적화 관점에 대해서 학습하였습니다.
부하테스트 관련하여 가용성 확보를 위한 다중화에 대한 설계 방향을 학습하였고 
성능 최적화 관련하여서는  성능과 확장 관련 스케일 아웃 스케일 업을 해야하는 시점과 
실제 지연시간이 발생하는 구간을 데이터로 확인하고 튜닝 대상을 선점하는 것에 대해 학습하였습니다. 
```

- 성능 튜님 경험이 있나요?
```
성능 모니터링 툴인 scouter를 활용하여 프로세스의 슬로우 쿼리를 개선한 경험이 있습니다. 
Sql 컬럼을 경량화하고 where in 서브쿼리를 조인 쿼리로 대체, 인덱스를 추가하는 방향으로 성능을 최적화하였습니다. 
```

- DB 설계 경험이 있나요?
```
DB설계 경험이 있습니다. 최근에는 로그 수집 관련 테이블을 설계하였습니다. 로그성 테이블에 대한 컬럼 추가를 하였으며, 그외로는 스터디 또는 사이드 프로젝트를 통해 해본 경험이 있습니다. 
```

- Git Flow에 대해 설명해주세요.
```
Git으로 개발할 때 거의 표준과 같이 사용되는 방법론입니다.
Git-flow는 총 5가지의 브랜치를 사용해서 운영을 합니다.
-master : 기준이 되는 브랜치로 제품을 배포하는 브랜치 입니다.
-develop : 개발 브랜치로 개발자들이 이 브랜치를 기준으로 각자 작업한 기능들을 합(Merge)칩니다.
-feature : 단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 develop 브랜치에 합칩니다.
-release : 배포를 위해 master 브랜치로 보내기 전에 먼저 QA(품질검사)를 하기위한 브랜치 입니다.
```

- API Batch 경험 어떤 것인지 구체적으로 말해주실수 있는 , 인증 방식은 어떤 식으로 했는지 말씀해주세요.
```
폐쇄망으로 구성된 각 API를 통신하거나 FTP를 통해 전송된 파일을 읽어드리는 배치를 개발하였습니다. 
ActiveX를 활용한 정보교환도 있으며 다양한 방법의 인터페이스를 구성하였습니다. 
경우에 따라 개인 정보에 대해서는 양방향 암호화를 하고, 
방화벽으로 구성된 네트워크 환경으로 따로 비즈니스 로직으로 인증 프로세스를 풀어내지는 않았습니다. 
```

- JWT 인증방식을 알고 있는지 설명해주세요.
```
JWT 는 JSON Web Token의 약자로 전자 서명 된 URL-safe (URL로 이용할 수있는 문자 만 구성된)의 JSON입니다.
해당 정보가 모든 정보를 가지고 있기에 전자 서명을 통해 JSON 의 변조를 체크 할 수 있게되어 있습니다

회원 인증: JWT 를 사용하는 가장 흔한 시나리오 입니다. 사용자가 로그인을 하면, 서버는 사용자의 정보를 기반으로한 토큰을 발급합니다. 그 후, 사용자가 서버에 요청을 할 때 마다 JWT를 포함하여 전달합니다. 서버는 클라이언트에서 요청을 받을때 마다, 해당 토큰이 유효하고 인증됐는지 검증을 하고, 사용자가 요청한 작업에 권한이 있는지 확인하여 작업을 처리합니다. 서버에서는 사용자에 대한 세션을 유지 할 필요가 없습니다. 즉 사용자가 로그인되어있는지 안되어있는지 신경 쓸 필요가 없고, 사용자가 요청을 했을때 토큰만 확인하면 되므로 세션 관리가 필요 없어서 서버 자원과 비용을 절감할 수 있습니다.

정보 교류: JWT는 두 개체 사이에서 안정성있게 정보를 교환하기에 좋은 방법입니다. 그 이유는, 정보가 서명이 되어있기 때문에 정보를 보낸이가 바뀌진 않았는지, 또 정보가 도중에 조작되지는 않았는지 검증할 수 있습니다.

```

- JWT 장점과 단점
```
장점
- URL  파라미터와 헤더로 사용
- 수평 스케일이 용이
- 디버깅 및 관리가 용이
- 트래픽 대한 부담이 낮음
- REST 서비스로 제공 가능
- 내장된 만료
- 독립적인 JWT

단점
- 토큰은 클라이언트에 저장되어 데이터베이스에서 사용자 정보를 조작 하더라도 토큰에 직접 적용할 수 없습니다.
- 더 많은 필드가 추가되면 토큰이 커질 수 있습니다.
- 비 상태 애플리케이션에서 토큰은 거의 모든 요청에 대해 전송 되므로 데이터 트래픽 크기에 영향을 미칠 수 있습니다.
```

- jpa에 대해 설명해주세요

```
자바 진영의 ORM 기술 표준입니다.

ORM은 `Object-relational mapping(객체 관계 매핑)
* 객체는 객체대로 설계
* 관계형 데이터베이스는 관계형 데이터베이스대로 설계
* ORM 프레임워크가 중간에서 매핑 객체와 RDB 두 기둥위에 있는 중간다리역할을 해줍니다. 


jpa를 왜 사용해야 할까?
* SQL 중심적인 개발에서 객체 중심으로 개발
* 생산성
* 유지보수
* 패러다임 불일치 해결
* 성능
* 데이터 접근 추상화와 벤더 독립성
* 표준
```

- 해왔 던 일에 대해 소개해주세요
```
저는 웹개발자로써, 백엔드 그리고 프론트 앤드 개발 등 다양한 기술을 바탕으로 시스템을 개발 및 운영 해왔습니다. 
KB생명보험에서는 모바일 기반의 비대면 방식의 영업지원시스템을 운영해왔습니다. 

개발환경은 java angularJs, Sping 기반으로 이루어져있습니다. 

개발 및 운영을 하면서, 테스트 중점적으로 진행을 하며, 이에 따라 점진적인 개선을 통해 안정적인 완성도를 높일수 있도록 항상 노력해왔습니다. 
```

- 이직 사유가 무엇인가요
```
비스 플랫폼의 백엔드 개발자로써, 커리어를 쌓고  좋은 환경과 좋은 개발자 동료를 만나고 싶어서 이직을 결심하게 되었습니다.  
```

- 마지막 한마디 해보세요.
```
개발자로써, 책임감있고 성실하게 일해왔습니다. 이번 면접을 통해 OOO에 입사하여 제 역량을 발휘하고 싶습니다. 
회사내에 시스템에 적용해보고 꾸준히 개선해 나가면서 성과를 이뤄낼 것을 약속드립니다.
```

- 웹 서버 구축 해본 경험을 말씀해주세요.
```
토이프로젝트를 통해 AWS EC2와 S3를 구성하고 연동해보는 작업을 해봤습니다.
최근에는 파이어베이스를 활용하여 스토리지, 호스팅을 통해 모바일웹페이지를 구성한 경험이 있습니다.
```

- Docker , 쿠버네티스 활용한 경험이 있나요?
```
학습해본 경험이 있습니다.
```

- MVC패턴과 MVVM패턴에 대해 설명해보세요
```
MVC란 Model View Controller의 약자로 애플리케이션을 세가지의 역할로 구분한 개발 방법론입니다. 사용자가 Controller를 조작하면 Controller는 Model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 됩니다.

MVVM 패턴이란, 
* Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분입니다.
* View : 사용자에서 보여지는 UI 부분입니다.
* View Model : View를 표현하기 위해 만든 View를 위한 Model입니다. View를 나타내 주기 위한 Model이자 View를 나타내기 위한 데이터 처리를 하는 부분입니다.
```

- React Redux에 대해 설명해보세요.

```
Redux를 사용하면 state를 별도의 전용 장소인 store에서 상태를 관리하고 React Component에서는 그걸 보여주기만 하는 용도로 사용합니다.
```

- 그럼 React의 Component는 무엇일까요
```
컴포넌트는 리액트로 만들어진 앱을 이루는 최소한의 단위입니다. 작으면서 단단한 컴포넌트와 만들어진 컴포넌트들
유기적으로 연결되어 동작을 할때, 좋은 앱이 만들어집니다. 컴포턴트는 데이터를 입력받아 DOM Node를 출력하는 함수입니다.
```

- Docker와 VM 차이를 설명하시오.


- DB 성능 튜닝 경험에 대해 설명하시오.
- DB 인덱스란
- Autoscaling에 대해 설명하시오.

- 쓰레드와 프로세스에 대해 설명하시오. 

```
프로세스란, 실행되는 프로그램의 메모리 할당을 받은 독립적인 인스턴스입니다.
독립적인 메모리 영역이기에 자원 공유가 어려우므로, 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스간 통신을 
사용해야 합니다.
```
- 자바에서 쓰레드란 무엇인가요
```
자바에서 JVM은 운영체제의 역할을 합니다.
자바에서는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록입니다.

자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어집니다.
- 스레드가 몇 개 존재하는지
- 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지
- 스레드의 상태는 무엇인지
- 스레드 우선순위는 얼마인지
```

- 멀티쓰레드에 대해 설명하시오.
```
쓰레드란 프로세스 내에서 실행되는 시간의 흐름 단위로 프로세스는 최소 하나 이상의 스레드를 갖는다는 것을 의미합니다.
그렇다면 멀티쓰레드란, 프로세스 내에 실행흐름단위를 동시에 처리할 수 있는 것을 의미합니다.
```

- 멀티쓰레드에 대한 장단점을 말씀해주세요.
```
장점으로는, 멀티쓰레드를 사용하면 하나의 프로세스에서 여러개의 쓰레드를 사용하기 때문에 자원소모가 줄어들며, 
시스템 처리량이 향상되고 응답시간을 단축할 수 있습니다. 
데이터영역과 힙영역을 공유하기에, 쓰레드간 데이터 교환이 필요하지 않습니다. 

단점으로는, 임계영역(둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 코드 블록) 공유하는 자원에 동시에 접근하는 경우, 프로세스와는 달리 스레드는 데이터와 힙 영역을 공유하기 때문에 어떤 쓰레드가 다른 쓰레드에서 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있습니다.
```

- 프로세스 메모리구조에 대해 설명해주세요.
```
프로그램이 실행되기 위해서는 메모리가 로드가 되어야합니다. 프로그램에서 사용되는 변수들을 저장한 메모리 공간이 필요합니다. 그러한 종류로 코드영역, 데이터영역, 힙영역, 스택영역이 있습니다. 
메모리의 코드 영역은 실행할 프로그램의 코드가 저장되는 영역입니다.
CPU는 코드영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.
데이터영역은 전역변수 또는 정적변수입니다. 프로그램 시작과 함께 할당되며 프로그램이 종료되면 소멸됩니다.
스택영역은 함수의 흐름과 관계되는 지역변수와 매개변수가 저장되는 영역을 의미합니다.
힙영역은 사용자가 직접관리할 수 있는 메모리 영역입니다. 메모리 공간이 동적으로 할당되고 해제가 됩니다./
```

- Garbage Collector 동작하는 원리에 대해 설명해주세요.
```
Garbage Collector를 통해서 메모리 반환을 합니다.
동적으로 할당했던 메모리 공간에서 필요없는 메모리 공간을 반환함으로써, 메모리 고갈 이슈를 방지합니다.

Garbage Collector의 동작원리로 STW(stop the world) Mark And Sweep이 있습니다. 
Stop the world 는 gc실행을 위해 JVM 애플리케이션을 멈추는 것을 의미합니다.
gc를 실행하는 쓰레드를 제외한 모든 스레드들이 작업을 멈추게 됩니다.
여기서 Mark and sweep라는 개념으로 이때 어떤 객체를 참조하고 잇는지 찾는 과정을 거치는데 이를 Mark라고 불리우며
Sweep은 참조되지 않은 객체는 제거하는 과정을 의미합니다.
```

- Context Switching 에 대해 설명해주세요.
```
CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 데 이 과정을 Context Switching 이라고 합니다. 
구체적으로, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 
대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 합니다. 
```

- REST API에 대해 설명해주세요
```
자원지향구조기반이며 각 자원의 고유한 URI를 두어 METHOD를 통헤 CRUD 작업을 하며 각 컴포넌트간 상호 작용을 촉진합니다.
```

- Hash란 무엇인가요

```
임의의 크기를 가진 데이터(Key)를 고정된 크기의 데이터(Value)로 변화시켜 저장하는 것

자바에서 hashCode()를 오버라이딩 할 때 단짝처럼 equals()도 오버라이딩 해야합니다. 
별개의 객체가 우연히 해시코드가 똑같이 나오게 되더라도, equals()로 값의 동등성을 한번 더 확인 하는 과정을 거치게 되면 충돌을 방지 할 수 있습니다.
```

- SOLID란 무엇인가요

SRP -> 단일책임원칙(Single Responsibility Principle) : "한 클래스는 하나의 책임만 가져야한다."

OCP -> 개방폐쇄원칙(Open/Closed principle) : "소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀있어야한다."

LSP -> 리스코프치환원칙(Liskov substitution principle) : "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
```
프로그램의 객체는 프로그램의 정확성 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야합니다. 
```
ISP -> 인터페이스분리원칙(Interface segregation principle) : "특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다
```
인터페이스 분리 원칙은 인터페이스는 자신의 쓰임새와 사용에 맞게끔 분리해야 한다는 원칙입니다.
특정 클라이언트를 위한 세세하게 분리하는 방법으로 이를 행합니다. 
```
DIP -> 의존관계역전원칙(Dependency Inversion Principle) : "추상화에 의존해야지, 구체화에 의존하면 안된다.
```
추상화에 의존하며 구체화에 의존하면 안된다는 것을 의미 합니다.
자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것
```

- 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가
```
1. 브라우저의 주소창에 url 입력
2. 브라우저 캐시에서 DNS 레코드를 확인하여 IP주소를 찾음 (없다면 DNS resolver를 통해 IP주소를 알아냄)
3. 브라우저가 서버와 TCP 연결을 시작함
4. 브라우저가 웹 서버에 HTTP 요청을 보냄
5. 서버가 요청을 처리하고 응답을 되돌려보냄
6. 브라우저는 서버가 보낸 HTML 내용을 표시
```

- 최근 사용해온 시스템 및 구조를 설명하시오
- java ArrayList 배열 사이즈 할당 되는 로직을 설명하시오.
```
ArrayList는 기존 배열과 달리 동적으로 사이즈 할당이 가능합니다.
기본은 사이즈를 10으로 진행하고 원소가 추가됨에 따라 size index에 값을 넣은 후 size를 1씩 증가시킵니다.
사이즈가 꽉 찼을 경우( Object[]의 크기보다 크다면 ) 기존 크기에서 50%의 크기를 더해서 새로운 크기를 
산정하게 됩니다.
```

https://sabarada.tistory.com/63?category=826240
https://www.nextree.co.kr/p6506/

- 리팩토링하면서 실무에서 어떻게 활용했었는지 말씀해주세요
```
중복을 제거하고 모듈화하거나, 불필요한 코드라든지 간소화할 수 있는 부분에 대해서 수정하는 방식으로 진행하였습니다. 
이를 통해서 코드량을 줄이고 재사용성을 높이는 방향으로 유지보수용이하도록 변경하였습니다.
```

- 협업하면서 리팩토링할 시 어려운 부분은 없었는지 말씀해주세요.
```
사실상 리스크가 큰 부분에 대해서는 먼저 의견을 제시하고 개선 여부에 대한 피드백을 받았습니다.
그 외 사소한 부분이나 리스크가 덜한 부분은 업무하면서 같이 수정을 하고 수정한 코드를 공유하는 방식으로 진행하였습니다.
```

- inner클래스는 왜 static이어야 하는지
```
외부 참조로 인한 단점이 더 분명하므로 내부 클래스는 static으로 만들어야합니다.
외부 참조는 2가지 단점이 있습니다
1. 참조값을 담아야 하기 때문에, 인스턴스 생성시 시간적, 공간적으로 성능이 낮아집니다.
2. 외부 인스턴스에 대한 참조가 존재하기, 가비지 컬렉션이 인스턴스 수거를 하지 못하여 메모리 누수가 생길 수 있습니다. 
```

- DI 종류와 선호하는 방식과 스프링에서 권장하는 DI는 무엇인가요
```
- 생성자 주입
- 필드 주입
- 세터 주입 
3가지 방법이 있으며 Spring에서 권장하는 방법은 생성자를 통한 주입입니다.

권장하는 이유는 
1. 단일 책임의 원칙
생성자의 인자가 많을 경우 코드량도 많아지고, 의존관계도 많아여 단일 책임의 원칙에 위배가 됩니다. 
그래서 생성자 주입을 사용함으로써, 의존관계 복잡성을 쉽게 알 수 있어 리팩토링의 단초를 제공하게 됩니다.
2. 테스트 용이성
DI 컨테이너에서 관리되는 클래스는 특정 DI 컨테이너에 의존하지 않고 POJO여야합니다. DI컨테이너를 사용하지 않고도
인스턴스화 할 수 있고, 단위 테스트도 가능하며 다른 DI 프레임워크로 전환할 수도 있게 됩니다.
3. Immutability
생성자 주입에서는 필드는 final로 선언할 수 있습니다. 불변 객체가 가능한데 비해
Field injection은 final는 선언할 수 없기 때문에 객체가 변경 가능한 상태가 됩니다.
4. 순환 의존성
생성자 주입에서는 멤버 객체가 순환 의존성을 가질 경우 beanCurrentlyCreationException 발생해서 순환 의존성을 알 수 있게 됩니다.
```

- 가비지 컬렉터 G1에 대해 설명해주세요.
https://imp51.tistory.com/entry/G1-GC-Garbage-First-Garbage-Collector-Tuning
https://mirinae312.github.io/develop/2018/06/04/jvm_gc.html
https://github.com/mkkim90/tech-interview/blob/master/contents/java.md
https://mangkyu.tistory.com/119?category=872426

- 가비지 컬렉터 G1의 장점에 대해 말씀해주세요
```
G1은 다른 GC 방식의 처리 속도를 능가하고 큰 메모리 공간에서 멀티 프로세스 기반으로 운영되는 애플리케이션을 위해
고안되었습니다. 

힙을 동일한 크기의 Region으로 나누고 가비지가 많은 Region에 대해 우선적으로 gc를 수행합니다.
```

- 자바 버전대별로 설명해주세요
https://namu.wiki/w/Java#s-4.9
https://johngrib.github.io/wiki/java-enhancements/
https://i3utterfly.tistory.com/entry/JAVA-%EB%B2%84%EC%A0%84%EB%B3%84-%EC%A0%95%EB%A6%AC


- git rebase란 무엇인가요
```
소스를 합치기 위한 명령어로써, 
브랜치를 합치고 정렬함으로써, Merge보다 업무 히스토리를 정리할 수 있는 장점이 있습니다.
```

- rebase -i

- primitive타입과 reference 타입을 말씀해주세요

- MSA(Micro Service Archetecture)에 대해서 설명해주세요.

```
중요 기능들을 작게 나누어 독립적인 모듈 실행이 가능하도록 합니다.
각 모듈의 추가, 수정, 배포, 복구 등등이 쉽고 해당 장애의 영향력을 최소화함으로써 유지보수성이 좋습니다.
```

- Spring Cloud에 대해 설명해주세요

```
Spring Cloud는 분산 시스템에서 공통적인 패턴을 모아 신속하게 구축할 수 있는 도구를 스프링 라이브러리 형태로
제공하는 것을 의미합니다.
```

- 온프레미스(On-premise)와 오프프레미스(Off-premise)
```
온프레미스는
자제적으로 보유한 전산실 서버에 직접 설치해 운영하는 방식입니다.
보안, 중요 비지니스 서비스와 데이터는 온프레미스 환경에서 작업하는 경우가 많습니다.

오프레미스는 클라우드를 일컫습니다.
서버, 스토리지, 네트워크, SW 등 자원이 필요할 때 인터넷을 통해 서비스 형태로 제공 받아 이용하는 방식입니다.
사용한 만큼 서버 비용을 지불합니다.
```

- 자바 접근제어자에 대해 설명해주세요. 

```
객체 지향에서 정보 은닉(data hiding)이란 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다는 개념입니다. 그렇게 함으로써 사용자는 언제나 최소한의 정보만으로 프로그램을 손쉽게 사용할 수 있게 됩니다.

자바에서는 이러한 정보 은닉을 위해 접근 제어자(access modifier)라는 기능을 제공하고 있습니다.
접근 제어자를 사용하면 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정하여 정보 은닉을 구체화할 수 있습니다.
자바에서는 다음과 같은 네 가지의 접근 제어자를 제공합니다.
1. private : 전체
2. public : 해당 클래스에서만 사용 가능합니다.
3. default : 같은 패키지에서만 사용 가능합니다.
4. protected : 같은패키지와 
```
